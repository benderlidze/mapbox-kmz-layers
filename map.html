<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <title>Extrude polygons for 3D indoor mapping</title>
    <meta name="viewport" content="initial-scale=1,maximum-scale=1,user-scalable=no">
    <link href="https://api.mapbox.com/mapbox-gl-js/v3.7.0/mapbox-gl.css" rel="stylesheet">
    <script src="https://api.mapbox.com/mapbox-gl-js/v3.7.0/mapbox-gl.js"></script>

    <script src="js/togeojson.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.0/jszip.min.js"></script>

    <script src="https://api.mapbox.com/mapbox-gl-js/plugins/mapbox-gl-geocoder/v5.0.3/mapbox-gl-geocoder.min.js"></script>
    <link rel="stylesheet" href="https://api.mapbox.com/mapbox-gl-js/plugins/mapbox-gl-geocoder/v5.0.3/mapbox-gl-geocoder.css" type="text/css">
    
    <style>
        body {
            margin: 0;
            padding: 0;
        }

        #map {
            position: absolute;
            top: 0;
            bottom: 0;
            width: 100%;
        }

        .mapboxgl-popup {
            max-width: 400px !important;
        }

        #layers {
            position: absolute;
            top: 10px;
            left: 10px;
            background: white;
            padding: 10px;
            border-radius: 5px;
            z-index: 100;
        }


        /* SWITCHER */
        .switcher-div {
            display: flex;
            align-items: center;
            margin: 5px;
        }

        .switcher-div>div {
            margin-left: 5px;
        }

        .switch {
            position: relative;
            display: inline-block;
            width: 35px;
            height: 15px;
        }

        .switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #ccc;
            -webkit-transition: 0.4s;
            transition: 0.4s;
        }

        .slider:before {
            position: absolute;
            content: "";
            height: 11px;
            width: 11px;
            left: 3px;
            bottom: 2px;
            background-color: white;
            -webkit-transition: 0.4s;
            transition: 0.4s;
        }

        input:checked+.slider {
            background-color: #2196f3;
        }

        input:focus+.slider {
            box-shadow: 0 0 1px #2196f3;
        }

        input:checked+.slider:before {
            -webkit-transform: translateX(18px);
            -ms-transform: translateX(18px);
            transform: translateX(18px);
        }

        .slider.round {
            border-radius: 34px;
        }

        .slider.round:before {
            border-radius: 50%;
        }

        .info-button {
            position: absolute;
            bottom: 10px;
            left: 10px;
            z-index: 1;
            border: 5px solid black;
            border-radius: 10px;
            background-color: white;
            display: flex;
            justify-content: center;
            align-items: center;
            width: 50px;
            height: 50px;
            font-size: 25px;
            cursor: pointer;
        }

        /* SWITCHER END */
    </style>
</head>

<body>
    <div id="map"></div>
    <div id="layers"></div>
    <script>
        const appData = {
            features: null,
            selectedLayers: []
        }
        const layersDiv = document.getElementById('layers')
        mapboxgl.accessToken = 'pk.eyJ1Ijoic2VyaHV6IiwiYSI6ImNseXpvc3RlczJpbnIya3FscDU2aHc5d3EifQ.FHtPjde_lqensSHZxqthgw';
        const map = new mapboxgl.Map({
            container: 'map',
            // Choose from Mapbox's core styles, or make your own style with Mapbox Studio
            style: 'mapbox://styles/mapbox/light-v11',
            center: { lng: -84.41437509399084, lat: 33.78968701476805 },
            zoom: 9,
        });

        //add search bar
        map.addControl(new MapboxGeocoder({
            accessToken: mapboxgl.accessToken,
            mapboxgl: mapboxgl
        }));

        map.on('load', () => {

            const files = [
                // 'data/BeltLine Access Points (Public Open and Interim).kml',
                // 'data/BeltLine Trails.kml',
                // 'data/1-Development Map.kmz',
                'data/My Places.kml',
                'data/ATL StreetCar.kmz',
                'data/Future LRTBRT (Beltline Rail, Clifton Corr).kmz',
                'data/MARTA Heavy Rail.kmz'
            ]

            Promise.all(files.map(file => fetch(file)))
                .then(responses => Promise.all(responses.map(response => response.blob())))
                .then(blobs => Promise.all(blobs.map(blob => {
                    console.log('blob', blob);

                    if (blob.type === "application/vnd.google-earth.kmz") {
                        const zip = new JSZip();
                        return zip.loadAsync(blob).then(zip => {
                            return zip.file("doc.kml").async("string").then(data => {
                                const kml = new DOMParser().parseFromString(data, "text/xml");
                                return toGeoJSON.kml(kml);
                            });
                        });
                    } else {
                        return blob.text().then(data => {
                            const kml = new DOMParser().parseFromString(data, "text/xml");
                            return toGeoJSON.kml(kml);
                        });
                    }
                })))
                .then(geojsons => {

                    console.log('geojsons', geojsons);

                    const features = geojsons.reduce((acc, geojson) => {
                        return acc.concat(geojson.features);
                    }, []);

                    const layerNames = [...new Set(features.map(f => f.properties.layerName))]
                    console.log('layerNames', layerNames);

                    layerNames.forEach(layer => {
                        appData.selectedLayers.push({
                            layer,
                            visibility: true
                        })

                        const property = buildSwitcher({
                            labelText: layer,
                            action: checked => {
                                const display = checked ? "visible" : "none"
                                const selLayer = appData.selectedLayers.find(l => l.layer === layer)
                                selLayer.visibility = checked

                                updateLayersVisibility()
                            },
                            checked: true
                        })
                        layersDiv.appendChild(property.nodeElement);
                    })

                    console.log('features', features);

                    features.forEach(f => {
                        if (f.geometry.type === "Point") {
                            f.properties.fill = "white"
                            if (f.properties.icon && f.properties.icon.includes("Layer0_Symbol_")) {
                                // const filename = f.properties.icon
                                // const color = filename.split('_')[2];
                                // f.properties.fill = '#' + color.slice(0, -2)

                                const color = f.properties.icon === 'Layer0_Symbol_f34c9f00_0.png' ? '#42c000' : '#c500ff'
                                f.properties.fill = color
                            }
                        }
                    })


                    map.getSource('geometry').setData({
                        'type': 'FeatureCollection',
                        'features': features
                    });

                    appData.features = features
                });


            // Create GeoJSON data for a building with 10 floors
            map.addSource('geometry', {
                'type': 'geojson',
                'data': {
                    'type': 'FeatureCollection',
                    'features': []
                }
            });

            map.addLayer({
                id: 'polygons',
                type: 'fill',
                source: 'geometry',
                paint: {
                    'fill-color': ['get', 'fill'],
                    'fill-opacity': 0.5
                },
                filter: ['==', '$type', 'Polygon']
            });

            map.addLayer({
                id: 'polygons-hovered',
                type: 'line',
                source: 'geometry',
                paint: {
                    'line-color': "white",
                    'line-width': 4
                },

            });

            map.addLayer({
                id: 'lines-hovered',
                type: 'line',
                source: 'geometry',
                paint: {
                    'line-color': "white",
                    'line-width': ['+', ['get', 'stroke-width'], 8]
                },
            })

            map.addLayer({
                id: 'lines',
                type: 'line',
                source: 'geometry',
                paint: {
                    'line-color': ['get', 'stroke'],
                    'line-width': ['get', 'stroke-width']
                },
                filter: ['==', '$type', 'LineString']
            })


            map.addLayer({
                id: 'points',
                type: 'circle',
                source: 'geometry',
                paint: {
                    'circle-color': ['get', 'fill'],
                    'circle-radius': 10,
                    'circle-stroke-width': 1,
                    'circle-stroke-color': "gray"
                },
                filter: ['==', '$type', 'Point']
            });


            map.loadImage(
                'tram.png',
                (error, image) => {
                    if (error) throw error;

                    // Add the image to the map style.
                    map.addImage('tram', image);

                    map.addLayer({
                        id: 'points-hovered',
                        type: 'circle',
                        source: 'geometry',
                        paint: {
                            'circle-color': "red",
                            'circle-radius': 15,
                        },
                        filter: ['==', '$type', 'Point']
                    });
                    map.setFilter('points-hovered', ['==', 'name', '']);

                    map.addLayer({
                        id: 'tram-icon',
                        type: 'symbol',
                        source: 'geometry',
                        layout: {
                            'icon-image': 'tram',
                            'icon-size': 1,
                            'icon-allow-overlap': true
                        },
                        filter: ['==', '$type', 'Point']
                    });

                }
            );

            map.setFilter('polygons-hovered', ['==', 'name', '']);
            map.setFilter('lines-hovered', ['==', 'name', '']);

            function pointerCursor(e) {
                map.getCanvas().style.cursor = 'pointer';
            }

            function defaultCursor() {
                map.getCanvas().style.cursor = '';
                map.setFilter('polygons-hovered', ['==', 'name', '']);
                map.setFilter('lines-hovered', ['==', 'name', '']);
                map.setFilter('points-hovered', ['==', 'name', '']);
            }

            map.on('mouseenter', 'polygons', pointerCursor);
            map.on('mouseleave', 'polygons', defaultCursor);
            map.on('mouseenter', 'points', pointerCursor);
            map.on('mouseleave', 'points', defaultCursor);
            map.on('mouseenter', 'lines', pointerCursor);
            map.on('mouseleave', 'lines', defaultCursor);


            map.on('mousemove', 'polygons', (e) => {
                //add hover effect over polygon 
                const props = e.features[0].properties
                map.setFilter('polygons-hovered', ['==', 'name', e.features[0].properties.name]);
            });
            map.on('mousemove', 'lines', (e) => {
                //add hover effect over line 
                const props = e.features[0].properties
                map.setFilter('lines-hovered', ['==', 'name', e.features[0].properties.name]);
            });
            map.on('mousemove', 'points', (e) => {
                //add hover effect over point 
                const props = e.features[0].properties
                map.setFilter('points-hovered', ['==', 'name', e.features[0].properties.name]);
            });

            function showInfo(e) {
                const features = map.queryRenderedFeatures(e.point);
                //remove douplicates from features
                const uniqueFeatures = features.filter((v, i, a) => a.findIndex(t => (t.properties.name === v.properties.name)) === i)
                console.log('uniqueFeatures', uniqueFeatures);

                const html = uniqueFeatures
                    .filter(feature => feature.properties.name)
                    .map(feature => {
                        descr = feature.properties.description ? feature.properties.description : ""
                        return `<h3>${feature.properties.name}</h3>
                                ${descr}`
                    })[0]
                // .join('');

                const popup = new mapboxgl.Popup()
                    .setLngLat(e.lngLat)
                    .setHTML(html)
                    .addTo(map);
            }

            //create a popup with all properties for all layers on click

            map.on('click', 'polygons', showInfo);
            map.on('click', 'lines', showInfo);
            map.on('click', 'points', showInfo);


        });

        function updateLayersVisibility() {


            const visibleLayers = appData.selectedLayers.filter(l => l.visibility).map(l => l.layer)
            console.log('visibleLayers', visibleLayers);

            const features = appData.features.filter(f => visibleLayers.includes(f.properties.layerName))

            map.getSource('geometry').setData({
                'type': 'FeatureCollection',
                'features': features
            });


        }


        function buildSwitcher({ labelText, action, colorCircle = false, checked = true }) {

            const div = document.createElement("div")
            div.className = "switcher-div"
            div.style.cursor = "pointer"

            const label = document.createElement("label")
            label.className = "switch"

            const checkbox = document.createElement("input")
            checkbox.type = "checkbox"
            checkbox.checked = checked

            // checkbox.addEventListener("input", () => {
            //     if (typeof action === "function") {
            //         action(checkbox.checked)
            //     }
            // })

            div.addEventListener("click", () => {
                checkbox.checked = !checkbox.checked
                if (typeof action === "function") {
                    action(checkbox.checked)
                }
            })

            function turnOn() {
                checkbox.checked = true
                if (typeof action === "function") {
                    action(checkbox.checked)
                }
            }

            function turnOff() {
                checkbox.checked = false
                if (typeof action === "function") {
                    action(checkbox.checked)
                }
            }

            const color = document.createElement("div")
            color.style.width = "10px"
            color.style.height = "10px"
            color.style.backgroundColor = colorCircle
            color.style.borderRadius = "10px"
            color.style.border = "1px solid #2196f3"

            const span = document.createElement("span")
            span.className = "slider round"

            const text = document.createElement("div")
            text.innerText = labelText

            label.appendChild(checkbox)
            label.appendChild(span)

            div.appendChild(label)
            if (colorCircle) div.appendChild(color)
            div.appendChild(text)

            return { nodeElement: div, turnOn, turnOff }
        }
    </script>

</body>

</html>